\chapter{Implementación}

A continuación se contará cómo se ha implementado el módulo de Bro, resolviendo así el problema planteado.

\intro La descripción del módulo será sin entrar en detalles de la programación. Se trata de una descripción 
como la descripción de una API.

\intro Lo primero que se va a detallar es la función para calcular el emparejamiento.

\begin{lstlisting}[style=CodigoC]
function emparejamiento(c1: connection, c2: connection ):double 

\end{lstlisting}

\intro Esta función recibe como entrada dos flujos y devuelve un número de tipo \textit{double}. En esta función 
lo que se hace es aplicar la fórmula de emparejamiento a los dos flujos que entran.

\intro Al querer hacer la comparación lo que se hace es sacar las IP's de origen y destino y los puertos de 
origen y destino de los flujos. También se obtendrán los \textit{timestamps} de los flujos, de esta forma se 
conseguirá la diferencia de tiempo. 

\intro Para poder operar con los puertos habrá que pasarlos a tipo \textit{count}, de esta forma se elimina la 
terminación con el tipo de protocolo del puerto. Se comentó anteriormente que se podía operar con esta terminación 
pero al tener que operar con otros tipos de datos que no son puertos es mejor quitar la terminación, pues de lo 
contrario no se obtendrá un buen resultado. 

\intro Lo mismo que con los puertos pasa con el tipo \textit{time}. Se puede operar con el tipo de dato 
\textit{time} pero no es recomendable hacerlo ya que se va a trabajar con más tipos de datos de carácter 
matemático.

\intro El número de veces que se tiene un flujo con los mismos datos o \textit{Nip}, en la fórmula, es de fácil 
cálculo. Gracias a la indexación basta con buscarlo en la tabla y calcular el tamaño del vector. 

\intro A continuación se procederá a la explicación de los distintos tipos de eventos usados y para que son usados.

\begin{lstlisting}[style=CodigoC]
event new_connection(c: connection)

\end{lstlisting}

\intro Este evento recibe como entrada un flujo nuevo. Este flujo es una nueva conexión, la cual no está identificada 
previamente. Esto quiere decir o que es nueva o que ha sido borrada.

\intro Este evento no devuelve nada, por lo tanto si en el momento en el que es detectado se tendrá que crear un nuevo 
indice o guardarlo en las tablas.

\intro Este tipo de evento detecta las conexiones de tipo \textit{TCP y UDP}.

\intro Ahora se verá cómo se van a gestionar la muerte de los flujos.

\begin{lstlisting}[style=CodigoC]
event connection_state_remove(c: connection)

\end{lstlisting}

\intro Este evento se activa cuando el flujo que entra en él va a morir, o ser borrado de la memoria. Es un flujo 
que ya ha sido procesado por el módulo.

\intro Lo que se realiza dentro de este evento es buscar en la tabla el índice el vector. De esta forma 
se borrará el primer flujo almacenado en el vector.

\intro De ser el único flujo almacenado en el vector, se borrará el vector entero. Si hay más flujos almacenados 
se moverán los demás una posición hacia atrás. De esta forma se seguirá teniendo un rendimiento óptimo.








