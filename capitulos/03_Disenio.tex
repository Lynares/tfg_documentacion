\chapter{Diseño y arquitectura del sistema}

En este capítulo se contará cómo se va a estructurar el módulo. Se explicará que funcionalidades debe de tener 
para que sea funcional. También se verá cómo gestiona Bro los flujos. 

\intro Todo esto será contado desde la vista del diseño, por lo tanto no se verá código, aunque se verán un par 
de tipos de datos interesantes. También se verá la arquitectura que seguirá el sistema.

\section{Arquitectura del sistema}

Para describir la arquitectura del sistema hay que tener en cuenta la arquitectura propia de Bro. Este monitor de 
red es un software modular. Esto quiere decir que esta compuesto de diferentes módulos que al ser ejecutados 
funcionan como un único sistema.

\intro Por lo tanto la arquitectura de este problema se debe de acoplar a la arquitectura propia de Bro. Esto 
quiere decir, que se construirá un módulo. Entre los requisitos del módulo a desarrollar se encuentra que sea 
ligero y eficiente. Por lo tanto se tendrá que usar los distintos eventos que proporciona Bro para crearlo de 
la forma deseada.

\intro Se prescindirá del uso de los \textit{frameworks} descritos en el capítulo anterior, pues su uso no aporta 
nada que no se pueda realizar exclusivamente con los eventos destinados a gestionar el tráfico de la capa de 
transporte. Con el uso de estos eventos y alguna función auxiliar para el cálculo del umbral de emparejamiento 
de forma que se realicen menos cálculos dentro de los propios eventos. Con este esquema será suficiente 
para alcanzar los objetivos propuestos.

\intro Entonces, a modo de resumen, la arquitectura final del sistema que se plantea será un módulo. Este estará 
compuesto por los distintos eventos de gestión del tráfico de la capa de transporte y una función auxiliar para 
el cálculo del umbral de emparejamiento. 

\section{Módulo y funciones}

Dado que una mala programación del módulo puede dejar al monitor de red colgado con una traza simple. Se tratará de 
que el módulo contenga solamente lo justo para llevar a cabo la identificación del tráfico. De esta forma se 
obtendrá un módulo cuya ejecución será óptima. 

\intro Las funcionalidades que se espera que tenga este módulo en esencia son dos, la detección y almacenado 
del tráfico y la aplicación de la fórmula, vista en el anterior capítulo, a los distintos flujos que se han 
detectado. De una forma más amplia las funciones del módulo serán las siguientes. 

\begin{itemize}
\item \textit{Función que aplique la fórmula de emparejamiento}. 
\intro A esta función se le pasará dos flujos, de forma que se aplique la fórmula y se discierna si pueden 
ser emparejados o no.
\item \textit{Funciones que detecten el tráfico}. 
\intro Esto se hará con los eventos de Bro. Los eventos detectarán el tipo de tráfico que se está analizando 
y aplicarán la función anterior.
\intro Tras el uso de esta fórmula se almacenará o no el flujo que está siendo analizado. Por lo tanto 
será necesario el uso de algún tipo de contenedor para este cometido.
\end{itemize}

\intro Lo que se espera es capturar el tráfico de la capa de transporte. Dicho tráfico se corresponde a los 
protocolos \textit{TCP y UDP}. Por lo tanto será necesario ver que tipo de eventos son los que controlan el tráfico 
de estos dos protocolos. Esto se verá de forma más amplia en la siguiente sección.

\intro Las entradas y salidas son de fácil gestión. Las entradas de tráfico podrán ser mediante archivos o 
analizando directamente el tráfico de la red. Las salidas, por su parte, serán mediante terminal. Esto puede 
suponer cierto inconveniente si se obtienen demasiadas salidas. También se pueden guardar las salidas en un 
fichero mediante el carácter >. Con esto se guardará en un fichero en la ruta que se especifique, siendo el 
posterior análisis mucho más cómodo desde, por ejemplo, un editor de texto.

\intro Se debe de tener en cuenta que siempre se podrá extender la funcionalidad del módulo. Pero de momento no 
resulta interesante. La posible extensión corresponde a posibles trabajos futuros.

\intro Para realizar este módulo es necesario conocer como gestiona los flujos Bro y de que forma se mantendrán 
los que son emparejados y los que están activos.

\section{Gestión de flujos}

La gestión de flujos en Bro pasa completamente por eventos. Por lo tanto se tendrá que crear variables globales 
para el almacenamiento de los flujos que sean emparejables y los que estén activos.

\intro El \textit{nacimiento de un flujo} es controlado por un evento. Por lo tanto cuando se detecta un nuevo 
flujo se lanza un evento. Este evento se tendrá que controlar de forma que si se tiene ya un flujo activo con las 
mismas características, se compare y se almacene. Si por el contrario no se tiene ningún flujo con esas 
características se tendrá que almacenar directamente en el contenedor de flujos activos.

\intro La \textit{muerte de un flujo} también es controlada por eventos. Ahora lo importante es si es interesante 
a nivel del análisis seguir almacenando los flujos aunque estos hayan muerto. Si no se quiere tener almacenados 
flujos muertos se tendrá que eliminar de la estructura en la que está almacenado. Si se quiere seguir trabajando 
con ellos habrá que mantenerlos guardados en la estructura. Obviamente si el flujo que va a morir está emparejado 
con otro se borrará solo del contenedor de flujos activos. Manteniéndose en el contenedor de flujos emparejados. De 
lo contrario se perderá información. Todo esto habrá que decidirlo en el evento que gestiona la muerte.

\intro Estos dos comportamientos de los flujos están controlados por eventos genéricos. Con un único evento se 
detecta que el flujo ha nacido o ha muerto, independientemente del tipo de protocolo al que pertenezca. No pasará 
esto con los distintos estados de los flujos que serán detectados. Pues no es lo mismo detectar un ACK de un flujo 
TCP que una respuesta de un flujo UDP. Serán tratados en eventos distintos y tendrán que ser gestionados con 
eventos distintos, cada uno destinado a un protocolo distinto. 

\intro A continuación se verán las estructuras de datos necesarias para llevar a cabo el desarrollo del módulo.

\section{Estructuras de datos}

Las principales estructuras de datos que se necesitan para el desarrollo de este trabajo serán dos tablas \cite{brotable} de 
vectores para el almacenamiento de los flujos activos y los emparejados. Los vectores son iguales que en cualquier 
otro lenguaje de programación, mientras que las tablas son parecidas a los \textit{maps} de \textit{C++}. Aunque 
esto se podrá ver con mejor detalle en el apartado de implementación.

\intro Dichas estructuras de almacenamiento, deberán de ser capaces de estar ordenados por las IP's y los puertos. 
Lo que se obtiene juntando las tablas con los vectores es precisamente esto. Una especie de matriz bidimensional, 
la cual está indexada. Por lo tanto se obtiene un acceso a los datos sea mucho más rápido. Incluso se podría 
prescindir de bucles, los cuales pueden acabar siendo un problema en cuanto a rendimiento si se llega a almacenar 
muchos flujos.

\intro Bro proporciona cierto tipos de datos muy interesantes y los cuales, además, incluyen mucha más información. 
Algunos de estos tipos de datos son. 
\begin{itemize}
\item \textit{connection}. \intro Este tipo de dato es el flujo en si. Por lo tanto será de vital comprenderlo para 
poder trabajar como se desea. Para obtener más información sobre este tipo de dato lea \cite{connectiontype}.
\item \textit{time}. \intro Este tipo de dato también es interesante. Aunque en otros lenguajes se puede obtener, 
en Bro es un tipo de dato por si mismo. Por lo tanto se podrá operar sobre él desde el principio, siendo una gran 
ventaja a la hora de calcular el tiempo de inicio de los flujos. Para leer más \cite{timetype}. 
\end{itemize}

\intro Estos dos tipos serán los más utilizados e interesantes, junto con los contenedores de los flujos. Hay más 
tipos de datos, incluso algunos extienden la información disponible sobre los flujos \cite{conntype}.
