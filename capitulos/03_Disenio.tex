\chapter{Diseño y arquitectura del sistema}

En este capítulo se contará cómo se va a estructurar el módulo. Se explicará que funcionalidades debe de tener para que sea funcional. También se verá cómo gestiona Bro los flujos. 

\intro Todo esto será contado desde la vista del diseño, por lo tanto no se verá código, aunque se verán un par de tipos de datos interesantes. También se verá la arquitectura que seguirá el sistema.

\section{Arquitectura del sistema}

En este problema la arquitectura que se va a emplear es una arquitectura modular. En dicha arquitectura el software 
se divide en grupos que son bien diferenciados, pero a la vez están muy bien acoplados los unos con los otros.

\intro Se podría pensar que para el módulo que se requiere, lo ideal sería usar el \textit{framework} de NetControl, presentado en el capítulo anterior, pero no es así. Dicho \textit{framework} aunque extiende la funcionalidad sobre las redes, es muy genérico. No aporta nada que sea de provecho para lo que se busca realizar.

\intro El módulo debe de ser ligero, para que el rendimiento sea óptimo. Por lo tanto se debe de prescindir de todo lo que no sea fundamental para la captura del tráfico en la capa de transporte y el posterior análisis de dicho tráfico.

\intro Por lo tanto la arquitectura final del sistema que se pretende construir será un módulo basado en los eventos relacionados con el tráfico en la capa de transporte y su funcionalidad deberá de ser solamente la necesaria para que el análisis sea lo más rápido posible. 

\section{Módulo y funciones}

El módulo que se pretende construir deberá de contar solamente con lo mínimo. De esta forma se pretende que su 
ejecución sea óptima. Una mala programación del módulo dejará al analizador de red ejecutando el análisis de forma 
indefinida. Para que sea óptimo la funcionalidad del módulo deberá de estar clara y presente siempre.

\intro Las funciones que se pretende que tenga este módulo en esencia son dos, la detección y almacenado 
del tráfico y la aplicación de la fórmula a los distintos flujos que se han detectado. De una forma más amplia 
las funcionalidades del módulo serán las siguientes. 

\begin{itemize}
\item \textit{Función que aplique la fórmula de emparejamiento}. 
\intro A esta función se le pasará dos flujos, de forma que se aplique la fórmula y se discierna si pueden 
ser emparejados o no.
\item \textit{Funciones que detecten el tráfico}. 
\intro Esto se hará con los eventos de Bro. Los eventos detectarán el tipo de tráfico que se está analizando 
y aplicarán la función anterior.
\end{itemize}

\intro Lo que es interesante es capturar el tráfico de la capa de transporte. Dicho tráfico se corresponde a los protocolos \textit{TCP y UDP}. 

\intro Se debe de tener en cuenta que siempre se podrá extender la funcionalidad del módulo. Pero de momento no resulta interesante. La posible extensión corresponde a posibles trabajos futuros.

\intro Para realizar esto es necesario conocer como gestiona los flujos Bro y de que forma se mantendrán los que 
son emparejados y los que están activos.

\section{Gestión de flujos}

La gestión de flujos en Bro pasa completamente por eventos. Por lo tanto se tendrá que crear variables globales 
para el almacenamiento de los flujos que sean potencialmente emparejables. 

\intro El nacimiento de un flujo es controlado por un evento. Por lo tanto cuando se detecta un nuevo flujo se 
lanza un evento. Este evento tendrá que ser usado para controlar si ya se tiene un flujo de características 
parecidas o por el contrario no. Esta decisión tendrá distintos efectos en el módulo. De no tenerlo detectado 
se tendrá que almacenar como un flujo activo nuevo. Si se tiene almacenado se deberá de comparar con los flujos 
activos almacenados que pueden ser emparejados.

\intro La muerte de un flujo también es controlada por eventos. Aquí lo importante es, si todavía es interesante 
a pesar de que este muerto, tener el flujo almacenado. Si no se quiere tener el flujo almacenado porque ya no 
está activo en el sistema, tendrá que ser almacenado en el mismo evento. Si se quiere almacenar porque puede 
seguir siendo útil para las comparaciones que se pueden realizar en el futuro, no se hará nada. 

\section{Estructura de datos}

Las principales estructuras de datos que se necesitan para el desarrollo de este trabajo serán dos vectores, o semejantes para el almacenamiento de los flujos activos y los emparejados. Aunque esto se podrá ver mejor en la implementación.

\intro Dichas estructuras de almacenamiento, deberán de ser capaces de estar ordenados por las IP's y los puertos. De esta forma se consigue que el acceso a los datos sea mucho más rápido. Incluso se podría prescindir de bucles, los cuales pueden acabar siendo un problema en cuanto a rendimiento si se llega a almacenar muchos flujos.

\intro Bro proporciona cierto tipos de datos muy interesantes y los cuales, además, incluyen mucha más información. 
Algunos de estos tipos de datos son. 
\begin{itemize}
\item \textit{connection}. \intro Este tipo de dato es el flujo en si. Por lo tanto será de vital comprenderlo para poder trabajar como se desea. Para obtener más información sobre este tipo de dato lea \cite{connectiontype}.
\item \textit{time}. \intro Este tipo de dato también es interesante. Aunque en otros lenguajes se puede obtener, en Bro es un tipo de dato por si mismo. Por lo tanto se podrá operar sobre él desde el principio, siendo una gran ventaja a la hora de calcular el tiempo de inicio de los flujos. Para leer más \cite{timetype}. 
\end{itemize}

\intro Estos dos tipos serán los más utilizados e interesantes, junto con los contenedores de los flujos. Hay más tipos de datos, incluso algunos extienden la información disponible sobre los flujos \cite{conntype}.

